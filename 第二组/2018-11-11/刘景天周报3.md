<font color = "red">ACM周报</font>
===

<font size = "5px"><font color = "purple">**刘景天**</font></font>


[comment]:名字必须基佬紫
# 1. 本周工作
- 把本周的编程作业写完了;
- 偶然学习到了qsort函数;
- 学会用sort/qsort函数对结构体数组进行排序;
- 全排列输出方法，do-while循环判断调用next_permutation;
- 完成了3次选拔赛的所有题目（截止交周报之前，第四次也会写的）;
- woc似乎没有了耶;
# 2. 下周计划
- 尝试继续写pta的题（真的是写不动了）;
- 随时等待俱乐部的任务;
- 继续看《算法竞赛 入门经典》;
- 没有了⑧;

# 3.学习心得
## 第三套基础语法练习题
- 贪心算法

>qsort函数要实现从大到小排序，cmp函数的返回值刚好与sort需要的返回值相反

我把贪心算法归结为寻求利益最大化为目的，第一个FatMouse' Trade的目标函数为能得到的javabean的总量，第二个是最多能买到的大米数，由于情景背景不一样，两道题的解法稍有不同。

第一个不同

第一道题需要通过计算javabean与catfood之间的兑换比例，进行排序，然后比例越高的一个就优先分配，并且要在catfood充足的情况下分配满，这样才能让mouse的利益得到最大化，而第二道题只需要对单价进行排序，越便宜的越先买。

第二个不同

第一道题不能用while循环判断自己的catfood有没有用完，我也不知道为什么，反正一改成for循环，把所有房间都遍历一遍就ok了

- 田忌赛马（贪心）


解决这道题的关键在于出马的策略 ：
>
>思路：
>
>　　贪心策略，为了使田忌利益最大化，每一步尽可能地消耗齐王的马。
>
>　1.若田忌最慢的马可以战胜齐王最慢的马，那么就让它战胜那匹慢马，胜场+1
>
>　2.若田忌最慢的马不能战胜齐王最慢的马，那么它更加不能战胜其他的马，那就让它输给齐王最快马，败场加1。
>
>　3.若田忌最慢的马与齐王最慢的马速度相等,分情况讨论：
>
>　　(1)如果此时田忌最快的马比齐王最快的马快，暂时先不用田忌的最慢马去消耗齐王的最快马了，先用田忌的最快马去vs齐王的最快马先赢一场，贪心算法（先赢一场再说）
>
>　　(2)如果田忌最快的马比齐王最快的马慢，那就用田忌的最慢马去消耗齐王的最快马。
>
>　　结果：最糟也能1胜1负，如果直接对攻，则必为1负1平。
>
>　　和局不产生比分差（可以忽略）


---------------------
作者：Raise 

来源：CSDN 

原文：https://blog.csdn.net/linraise/article/details/19175801 

### B - 今年暑假不AC
这道题的思路也是很重要的，首先要对节目进行排序，如果按照开始时间排序，遇到都满足条件的分支时，需要都考虑一遍，还要考虑分支的分支，有点难，但如果按照结束时间排序，这样一次性下来，相当于挑选那些时间相对更短的，在相同时间内看时间更短的那些节目

### H - 排列2
没有学会全排列算法，最后用do-while在判断里面调用next_permutation函数，

## 第一次选拔赛
### A
这道题题解的办法还是没有懂，但是在同学的帮助下，用类似贪心的算法解出来了，首先既然是保证一等奖尽量大，在保证二等奖尽量大，所以让1，2都变成对应的max，然后让三等奖等于总数-一等奖-二等奖，然后三等奖可能小于min，要补缺口，优先用二等奖补，够补只用二等奖补，不够补把二等奖变成min，剩下的用一等奖补。

### B
按照题意模拟，两个数组，输入后都不要改变顺序，一个存成绩，一个存是否为成功学生，为bool类型，然后循环的一个个比每个学生的每个成绩是不是最高，最高就让对应的bool变成true，ans++，但是如果已经是成功学生了，就不ans++

### C
按照题意模拟，循环找自己的需要有没有对应的瓶子能开，就让对应的记录+1，如果有重复的瓶子，只需要考虑不要让其他瓶子重复计算可开瓶子的数目就好，所以让对应的记录等于一，不自增就可以了

### D
```c++
#include <iostream>
#include <algorithm>
#include <string.h>
using namespace std;

int main()
{
    int n, k;
    scanf("%d%d", &n, &k);
    char pass[n][128] = {0};
    int len[n] = {0};
    for (int i = 0; i < n; i++) {
        scanf("%s", pass[i]);
        len[i] = strlen(pass[i]);
    }
    char correct[128] = {0};
    scanf("%s", correct);
    int len_c = strlen(correct);
    sort(len, len+n);
    int min = 0,equal = 0;
    for (int i = 0; i < n; i++) {
        if (len[i] < len_c) {
            min++;
        } else if (len[i] == len_c) {
            equal++;
        } else {
            break;
        }
    }
    int time_s = 0;
    int time_m = 0;
/*
    time_s = (min)/k*5+min + 1;
    time_m = (min+equal)/k*5+min+equal;
*/
//不知道为什么不能这么写
    time_m = time_s = (min)/k*5+min;
    time_s++;
    time_m += (min%k+equal-1)/k*5+equal;

    printf ("%d %d\n", time_s, time_m);

    return 0;
}

```

### E

fn modulo 1000000007 (10^9 + 7).

要这么算
(a % 1000000007 + 1000000007) % 1000000007;

### F
按照题意模拟就好

## 第二次选拔赛
### B
如果不需要买，就直接输出0

如果余数为1（买3本），需要考虑买3个1本，1个3本，1个1本+1个2本

如果余数为2，需要考虑买2个1本，1个2本，2个3本

如果余数为3，需要考虑买1个1本，5个2本，3个3本

### D
考虑不共线（方向向量），AB=BC;
### E
一点点的找非降子序列的长度，全部存起来，然后排序输出最大值

## 第二次选拔赛

### A
优先走5步，再走4步，。。。
可以直接总数除5得商，是5步的步数，余数在循环，4步，同样的方法

### B
等差数列，先要求第t个是啥，要知道他在第几行，直接带公式，用unsigned long long int接收（否则怕过不了），去掉小数，就是所在行了，然后算出到这一行一个有几个，减去要求的t，是0就是本行最后一个，不是0就是两数的差

### C
哈哈哈，王和兴的作业题

### D
从一个点到另一个点的步数是一定的，因为只能上下左右，只有整数点，所以如果步数相等，可以过去，小于，一定不行，如果大于，那就看超出的部分是不是偶数，是偶数的话多走一半在走回来那一半

### E
求两点间距离，看它除以直径有商是多少（就是先沿着两点间线段往过走），然后看有没有剩下，剩下就再多一步。

### F
不能简单的理解为第一行需要1s，第二行需要2s，第三行需要3s，因为从两边到中间的杯子分到上面留下来的酒的股数不一样，时间快慢也就不一样，所以要进行模拟。

把图片旋转90度，通过模拟情境，倒酒一秒，第一个杯子加1，表示一杯，再过一秒，再加1
此时大于1杯，要溢出，分别分一半给pyr[1][2]和pyr[2][2],再加酒，重复上述过程，
如果pyr[1][2]和pyr[2][2]满了，就在往下一杯倒酒，各分0.5，所以的杯子都往跟他下一列
的同行的和下一列同行+1的杯子里同分别分0.5.最后让自己这杯变成1，表示刚好满了
pyr[1][1]表示
